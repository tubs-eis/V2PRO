/*
 *  * Copyright (c) 2024 Chair for Chip Design for Embedded Computing,
 *                    Technische Universitaet Braunschweig, Germany
 *                    www.tu-braunschweig.de/en/eis
 * 
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT
 * 
 */
// ###############################################################
// # vpro_asm.h ASSEMBLE Wrapper Functions for VPRO Issueing     #
// ###############################################################

#ifndef vpro_asm_h
#define vpro_asm_h

//#ifndef SIMULATION
#include <cassert>
#include <cinttypes>
#include <cstdarg>
#include <array>
#include <list>
//#include <stdio.h>

/**
 * Emit of VPRO Commands via special Registerfile
 * Call examples:
 * ```
 *      // to VPRO[1]
 *      // param id <= L0_1, param func <= FUNC_ADD
 *      // trigger
 *      int a = L0_1, b = FUNC_ADD;
 *      c_vpro_lw<1, id, func, Trigger>(a, b);
 *
 *      // to VPRO[7]
 *      // all 16 parameters <= a (= 0)
 *      // no trigger
 *      c_vpro_li<7, 0b1111111111111111, NoTrigger>(a);
 *  ```
 */
namespace VPRO_RISC_EXT_VPRO {

#define VPRO_REGISTER_INDEX_SIZE 3
#define VPRO_PARAMETERS 13
#define VPRO_PARAMETER_INDEX_SIZE 4
#define VPRO_TRIGGER_SIZE 1

#define N_ONES(n) (-1u >> (32-(n)))
#define N_ZEROS(n) ~(-1u >> (32-(n)))

    /**
     * Inside the VPRO CMD Register, these indizes can be used to modify several parameters of the cmd
     */
    enum VPRO_PARAMETER_INDIZES {
        id = 0, /*!< =0 | modifies the id (Lane) */
        func = 1, /*!< =1 | modifies the command function */
        dst_offset = 2, /*!< =2 | modifies DST offset */
        dst_all = 3, /*!< =3 | modifies DST offset, alpha, beta */
        src1_flag = 4, /*!< =4 | modifies SRC1 flags (chain/reg/imm) */
        src1_offset = 5, /*!< =5 | modifies SRC1 offset */
        src1_all = 6, /*!< =6 | modifies SRC1 offset, alpha, beta (not the src flag) - Generated by SRC1_REG(offset, alpha, beta)*/
        src2_flag = 7, /*!< =7 | modifies SRC2 flags (chain/reg/imm) */
        src2_offset = 8, /*!< =8 | modifies SRC2 offset */
        src2_all = 9, /*!< =9 | modifies SRC2 offset, alpha, beta (not the src flag) - Generated by SRC2_REG(offset, alpha, beta)*/
        src2_imm = 10, /*!< =10 | modifies SRC2 offset, alpha, beta, sets the flag to IMM (especially used for Load Offset) - Generated by SRC2_IMM(value)*/
        x_y_z_end = 11, /*!< =11 | modifies xend */
//        yend = 12, /*!< =12 | modifies yend */
//        zend = 13, /*!< =13 | modifies zend */
//        chain_flag = 14, /*!< =14 | modifies chaining flag */
        chain_blocking_update_flag = 12, /*!< =15 | modifies blocking and update flags (bit '1 = blocking and bit '0 = update) */
        nowhere = 15,   /*!< Relevant for lw */
    };

    enum TRIGGER {
        NoTrigger = 0,  /*!< = 0 | false, not triggering the VPRO Cmd with this instruction */
        Trigger = 1     /*!< = 1 | true, triggering the VPRO Cmd with this instruction */
    };


    /**
     * generates the mask to modify selected parameters of the command at once
     * @param d e.g. id / func
     * @return the mask
     */
    constexpr uint32_t create_index_mask(VPRO_PARAMETER_INDIZES d) {
        uint32_t result = 0;
        result |= 0b1 << d;
        return result;
    }

    constexpr uint32_t create_index_mask(VPRO_PARAMETER_INDIZES d, VPRO_PARAMETER_INDIZES d2) {
        uint32_t result = 0;
        result |= 0b1 << d;
        result |= 0b1 << d2;
        return result;
    }

    constexpr uint32_t
    create_index_mask(VPRO_PARAMETER_INDIZES d, VPRO_PARAMETER_INDIZES d2, VPRO_PARAMETER_INDIZES d3) {
        uint32_t result = 0;
        result |= 0b1 << d;
        result |= 0b1 << d2;
        result |= 0b1 << d3;
        return result;
    }

    constexpr uint32_t create_index_mask(VPRO_PARAMETER_INDIZES d, VPRO_PARAMETER_INDIZES d2, VPRO_PARAMETER_INDIZES d3,
                                         VPRO_PARAMETER_INDIZES d4) {
        uint32_t result = 0;
        result |= 0b1 << d;
        result |= 0b1 << d2;
        result |= 0b1 << d3;
        result |= 0b1 << d4;
        return result;
    }

    /**
     * constexpr to generate single immediate (12 bit)
     * @param register_index
     * @param src1_target_index
     * @param src2_target_index
     * @param trigger
     * @return
     */
    constexpr int32_t vpro_lw_imm(uint32_t register_index, uint32_t src1_target_index, uint32_t src2_target_index,
                                  uint8_t trigger) {
        static_assert((VPRO_REGISTER_INDEX_SIZE + 2 * VPRO_PARAMETER_INDEX_SIZE + VPRO_TRIGGER_SIZE) <= 12);

        register_index &= N_ONES(VPRO_REGISTER_INDEX_SIZE);        // 0...7
        src1_target_index &= N_ONES(VPRO_PARAMETER_INDEX_SIZE);    // 0...15
        src2_target_index &= N_ONES(VPRO_PARAMETER_INDEX_SIZE);    // 0...15
        trigger &= N_ONES(VPRO_TRIGGER_SIZE);                // 0...1

        // in total 12 bit immediate here!

        uint32_t val = (
                (register_index << (2 * VPRO_PARAMETER_INDEX_SIZE + VPRO_TRIGGER_SIZE)) |
                (src1_target_index << (VPRO_PARAMETER_INDEX_SIZE + VPRO_TRIGGER_SIZE)) |
                (src2_target_index << VPRO_TRIGGER_SIZE) |
                trigger
        );

        // asm dont take 12-bit unsigned, but signed values... fake as signed

        if ((val & 0x800) != 0)
            return int32_t(val | 0xfffff800);
        return int32_t(val);
    }

    /**
     *  Use VPRO CMD Registerfile to generate a command for the VPRO.
     *  Execution can be started by the triger flag.
     *  Command is modified with 2 values from the EIS-V Registerfile with this instruction
     * @tparam register_index   Target Register of VPRO Cmd Registerfile
     * @tparam src1_target_index    Target Parameter Index in VPRO Cmd to be written by a (inside VPRO CMD Registerfile)
     * @tparam src2_target_index    Target Parameter Index in VPRO Cmd to be written by b (inside VPRO CMD Registerfile)
     * @tparam trigger  Flag if VPRO CMD should be emitted by this command
     * @param a value to be written in VPRO CMD
     * @param b value to be written in VPRO CMD
     */
    template<uint32_t register_index, uint32_t src1_target_index = nowhere, uint32_t src2_target_index = nowhere, uint8_t trigger = NoTrigger>
    inline void c_vpro_lw(const uint32_t a, const uint32_t b) {

        static_assert((register_index & N_ZEROS(VPRO_REGISTER_INDEX_SIZE)) == 0);
        static_assert((src1_target_index & N_ZEROS(VPRO_PARAMETER_INDEX_SIZE)) == 0);
        static_assert((src2_target_index & N_ZEROS(VPRO_PARAMETER_INDEX_SIZE)) == 0);
        static_assert((trigger & N_ZEROS(VPRO_TRIGGER_SIZE)) == 0);

        asm ("vpro.lw %0, %1, %2\n\t"
                : /* No outputs. */
                : "r" (a), "r" (b), "i" (vpro_lw_imm(register_index, src1_target_index, src2_target_index, trigger)));
    }

    /**
     * constexpr to generate single immediate (20 bit)
     * @param register_index
     * @param index_mask
     * @param trigger
     * @param is_increment
     * @param inc_imm
     * @return
     */
    constexpr int32_t vpro_li_imm(uint32_t register_index, uint32_t index_mask = 0, uint8_t trigger = NoTrigger,
                                  uint8_t is_increment = 0, uint8_t inc_imm = 0) {
        static_assert((VPRO_REGISTER_INDEX_SIZE + VPRO_PARAMETERS + VPRO_TRIGGER_SIZE + 1 + 2) <= 20);

        register_index &= N_ONES(VPRO_REGISTER_INDEX_SIZE);     // 0...7 = 3 bit
        index_mask &= N_ONES(VPRO_PARAMETERS);                  // 12 bit
        trigger &= N_ONES(VPRO_TRIGGER_SIZE);                   // 0...1 = 1 bit

        // in total 20 bit immediate here!
        uint32_t val = (
                ((inc_imm & 0b11) << (1 + VPRO_REGISTER_INDEX_SIZE + VPRO_PARAMETERS + VPRO_TRIGGER_SIZE)) |
                ((is_increment & 0b1) << (VPRO_REGISTER_INDEX_SIZE + VPRO_PARAMETERS + VPRO_TRIGGER_SIZE)) |
                (register_index << (VPRO_PARAMETERS + VPRO_TRIGGER_SIZE)) |
                (index_mask << VPRO_TRIGGER_SIZE) |
                trigger
        );

        // asm take 20-bit signed...
        if ((val & 0x80000) != 0)
            val = val | 0xffff8000;

        // jal offset needs to be aligned to 16-bit (this immediate is interpreted as jal immediate)
        //val = val << 1;

        return int32_t(val);
    }

    /**
     *  Use VPRO CMD Registerfile to generate a command for the VPRO.
     *  Execution can be started by the triger flag.
     *  Command is modified with 1 values from the EIS-V Registerfile with this instruction
     * @tparam register_index   Target Register of VPRO Cmd Registerfile
     * @tparam index_mask Target Parameter Index Mask in VPRO Cmd to be written by a (inside VPRO CMD Registerfile)
     * @tparam trigger Flag if VPRO CMD should be emitted by this command
     * @tparam is_increment If set, the value will be added to the specific selected parameters of the vpro
     * @tparam increment_use_imm_instead_rf If set, the value will not be used from Registerfile (variable) but as immediate with 6-bit
     * @param value value to be written in VPRO CMD
     */
    template<uint32_t register_index, uint32_t index_mask = 0, uint8_t trigger = NoTrigger, uint8_t is_increment = false,
            uint8_t use_imm_instead_rf = false>
    inline void c_vpro_li(const uint32_t value) {
        static_assert((register_index & N_ZEROS(VPRO_REGISTER_INDEX_SIZE)) == 0);
        static_assert((index_mask & N_ZEROS(VPRO_PARAMETERS)) == 0); // bits 0...16 are ok
        static_assert((trigger & N_ZEROS(VPRO_TRIGGER_SIZE)) == 0);

        assert((value & N_ZEROS(8)) == 0);

        uint8_t inc_imm;
        uint8_t inc_imm_r;
        if (use_imm_instead_rf) {
            inc_imm = (value & 0x60) >> 5; // bit nr 7.,6.
            inc_imm_r = value & 0x1f; // 5 bits
            switch (inc_imm_r) {
                case 0:
                    asm ("vpro.li x0, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 1:
                    asm ("vpro.li x1, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 2:
                    asm ("vpro.li x2, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 3:
                    asm ("vpro.li x3, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 4:
                    asm ("vpro.li x4, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 5:
                    asm ("vpro.li x5, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 6:
                    asm ("vpro.li x6, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 7:
                    asm ("vpro.li x7, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 8:
                    asm ("vpro.li x8, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 9:
                    asm ("vpro.li x9, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 10:
                    asm ("vpro.li x10, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 11:
                    asm ("vpro.li x11, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 12:
                    asm ("vpro.li x12, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 13:
                    asm ("vpro.li x13, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 14:
                    asm ("vpro.li x14, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 15:
                    asm ("vpro.li x15, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 16:
                    asm ("vpro.li x16, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 17:
                    asm ("vpro.li x17, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 18:
                    asm ("vpro.li x18, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 19:
                    asm ("vpro.li x19, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 20:
                    asm ("vpro.li x20, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 21:
                    asm ("vpro.li x21, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 22:
                    asm ("vpro.li x22, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 23:
                    asm ("vpro.li x23, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 24:
                    asm ("vpro.li x24, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 25:
                    asm ("vpro.li x25, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 26:
                    asm ("vpro.li x26, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 27:
                    asm ("vpro.li x27, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 28:
                    asm ("vpro.li x28, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 29:
                    asm ("vpro.li x29, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                case 30:
                    asm ("vpro.li x30, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                    break;
                case 31:
                    asm ("vpro.li x31, %0\n\t"
                            : /* No outputs. */
                            : "i" (vpro_li_imm(register_index, index_mask, trigger, is_increment, inc_imm)));
                    break;
                default:
//                    printf("[Error][VPRO] Issue with imm in c_vpro_li OOR!\n");
                    break;
            }
        } else {
            // 20bit immm, 5bit reg
            asm ("vpro.li %0, %1\n\t"
                    : /* No outputs. */
                    : "r" (value), "i" (vpro_li_imm(register_index, index_mask, trigger)));
        }
    }

    /**
     * Trigger the current VPRO Cmd from VPRO Registerfile
     * Dont modify the Command
     */
    template<uint32_t register_index>
    inline void c_vpro_trigger() {
        c_vpro_lw<register_index, nowhere, nowhere, Trigger>(0, 0);
    }

    /**
     * Helper to call c_vpro_li with incrementing the selected parameters with variable integer
     * @tparam register_index   Target Register of VPRO Cmd Registerfile
     * @tparam index_mask Target Parameter Index Mask in VPRO Cmd to be written by a (inside VPRO CMD Registerfile)
     * @tparam trigger Flag if VPRO CMD should be emitted by this command
     * @param value incremented amount
     */
    template<uint32_t register_index, uint32_t index_mask, uint8_t trigger>
    inline void c_vpro_add(const uint32_t value) {
        c_vpro_li<register_index, index_mask, trigger, true, false>(value);
    }

    /**
     * Helper to call c_vpro_li with incrementing the selected parameters with an Immediate value
     * @tparam register_index   Target Register of VPRO Cmd Registerfile
     * @tparam index_mask Target Parameter Index Mask in VPRO Cmd to be written by a (inside VPRO CMD Registerfile)
     * @tparam trigger Flag if VPRO CMD should be emitted by this command
     * @param value incremented amount. Needs to be an immediate value!
     */
    template<uint32_t register_index, uint32_t index_mask, uint8_t trigger>
    inline void c_vpro_addi(const uint32_t value) {
        c_vpro_li<register_index, index_mask, trigger, true, true>(value);
    }
}

// TODO: add DMA Registerfile

//#endif // ndef simulation
#endif // vpro_asm_h
